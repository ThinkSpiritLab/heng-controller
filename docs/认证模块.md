# 认证模块

## RoleSignGuard

主要内容。

作用：

1. 根据请求中提供的AccessKey及http签名验证其角色
2. 验证http请求是否被窜改

## KeyModule

提供密钥对及其所具有的权限的CRUD接口，使用Redis存放各角色的密钥对，实现方法为为各角色开一个Hash

### 接口

#### 访问权限

Root

#### 格式

**全部采用请求体数据，主要以下两种类型**：

1. KeyCriteriaArrDTO

   意义：一个查询条件的JSON字符串,包含一个数组`list`。每个元素类型为`KeyCriteria`，表示一个查询h操作的条件。认为每次请求都需批量查询或添加

   定义：

   ```typescript
   export class KeyCriteriaArrDTO {
       @IsArray()
       @ArrayNotEmpty()
       @ValidateNested({ each: true })
       @Type(() => KeyCriteria)
       readonly list!: KeyCriteria[];
   }
   ```

   示例：

   ```json
   {
       "list": [
           {
               "ak": "xxxxxxxxxxxxxxxxxx...",
               "sk": "xxxxxxxxxxxxxxxxxx...",
               "roles": [
                   "admin",
                   "judger"
               ]
           },
           {
               "ak": "xxxxxxxxxxxxxx...",
               "sk": "xxxxxxxxxxxxxx...",
               "roles": [
                   "judger"
               ]
           }
       ]
   }
   ```

   约束：

   - roles不能包含"root"

   逻辑：

   ​	  (不能使KeyPair中的sk在某些位置变为可选项，)

2. KeyPairArrDTO

   意义：  

   定义：

   ```typescript
   export class RoleCriteriaArrDTO {
       @IsArray()
       @ArrayNotEmpty()
       @ValidateNested({ each: true })
       @Type(() => RoleCriteria)
       readonly list!: RoleCriteria[];
   }
   ```

   示例：

   

   

3. RoleCriteria

4. RoleCriteriaArrDTO

5. 内容：

| 路径                | 方法 | 解释                                                | 请求体              | 响应 |
| ------------------- | ---- | --------------------------------------------------- | ------------------- | ---- |
| `/key/gennerateAdd` | POST | 为每个条件添加一个具有其属性`roles`中的角色的密钥对 | KeyCriteriaArrDTO() |      |
|                     |      |                                                     |                     |      |
|                     |      |                                                     |                     |      |



1. POST `/key/gennerateAdd`

   请求体：
   
   - ` generateAddKeyPair`签发具有对应角色的密钥对并加入redis
   
   
   
2. DELETE `/key/del`
    Body: keyCriteriaArrDTO,

  - `deleteKeyPair`删除密钥对

3. GET `/key/findAllByRoles`

   Body: keyCriteriaArrDTO

   - `findAllByRoles`获取给定角色的所有密钥对

4. GET `/key/findOne`

   - `findOne`根据AccessKey和可选参数role获取密钥对，暂不支持根据多个role获取

5. POST `/key/add`

   - 向add的请求应包含一个KeyPair类型具有的字段"ak","sk",“role"（可选）

#### 测试接口

1. `/keytest/generate`
2. `/keytest/add`
3. `/keytest/getall`

### Service

1. `generateKeyPair`生成一个密钥对

```typescript
async generateKeyPair(roles: string[]): Promise<KeyPair>
```

2. `generateAddKeyPair`生成一个密钥对，其具有roles中含有的角色

```typescript
async generateAddKeyPair(roles: string[]): Promise<KeyPair>;
```

2. `deleteKeyPair`根据公钥accessKey删除密钥对或其具有的角色，若不提供角色，默认删除所有角色。

```typescript
async deleteKeyPair(
  accessKey: string,
  roles?: string[]
): Promise<{ RemovedRoles: string[]; SccessNum: number }>;
```

3. 获取所有密钥对，返回一个键为角色类型，值为密钥对列表的FindAllKeysRecord

```typescript
async findAllKeyPairs(): Promise<FindAllKeysRecord>；
```

4. `findKeyPair`根据所提供的accessKey和的可选参数role角色在RedisHash中查找密钥对

不提供role则对所有角色的Hash中查找

```typescript
async findKeyPair(accessKey: string, role?: string): Promise<KeyPair>；
```

5. `addKeyPair`将所提供的密钥对keyPair添加到对应其角色role的RedisHash中

```typescript
async addKeyPair(keyPair: KeyPair): Promise<number>
```

## 常量及类型

### 密钥的相关属性

#### 长度、类型

- `rootAccessKey及rootSecretKey`：在application.toml中手动输入生成配置前生成好的，长度为64-256
- 其他：`KEY_LENGTH_NOT_ROOT=64`

#### 生成方式

crypto库中的`generateKeyPairSync()`,带有PUBLICKEY/SECETKEY等字样的前缀或后缀，需截取中间部分1到4行，取中间64位。之所以不采用

```typescript
let { publicKey, privateKey } = generateKeyPairSync("rsa", {
            modulusLength: KEY_LENGTH_NOT_ROOT * 16,
            publicKeyEncoding: {
                type: "spki",
                format: "pem"
            },
            privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
            }
        });
```

在日志中输出accessKey时取前KEY_SHOW_LENGTH位

需将生成的pem格式的key中的**保留字符**：/和+替换掉

### ```RoleTypeArr:string[]```

存角色的数组

内容：```["root", "admin", "judger", "user"]```

### ```PublicHeadersType:string[]```

公共请求头，在guard中使用（遍历）时按字典序排序

### ```whiteHeaders:string[]```

请求头白名单，计入签名

### KEY_SHOW_LENGTH

日志中展示的密钥对的长度

### KeyPair

```typescript
type KeyPair = {
   ak: string | null;
   sk: string | null;
   roles?: string[] | null;
};
```

密钥对格式。```ak:AccessKey``` ``` sk:SecretKey``` ``` roles:密钥对具有的角色```

### FindAllKeysRecord

保存各个角色对应的密钥对的列表的字典

```typesctipt
export type FindAllKeysRecord = Record<string, Record<string, string>>;
```

eg:

```typescript
{
"root":{
  "blablaba":"blablabla"
},
"admin":{
  "blablaba":"blablabla",
    "blablaba":"blablabla"
},
"judger":{
  "blablaba":"blablabla",
    "blablaba":"blablabla"
}
}
```

### KeyPairDTO

KeyPair对应的DTO，ak、sk、roles都不能为空，以便`addKeyPair`时进行处理

```typescript
export class KeyPairDTO {
    @IsString()
    @IsNotEmpty()
    @Length(KEY_LENGTH_NOT_ROOT, KEY_LENGTH_NOT_ROOT, {
        message: lengthErrorMessage
    })
    ak!: string;

    @IsString()
    @IsNotEmpty()
    @Length(KEY_LENGTH_NOT_ROOT, KEY_LENGTH_NOT_ROOT, {
        message: lengthErrorMessage
    })
    sk!: string;

    @IsString()
    @IsNotEmpty()
    roles!: string[];
}

```

### Redis键含义

```typescript
export const keyPoolPre = "KeyPool";
```

格式为``${keyPoolPre}:${role}``其中role为`RoleTypeArr`中定义的角色

## 管道

### StringToArrPipe

#### 构造参数

`belongToVals[]:string[]`： 表示请求中(或controller中)的参数转换为列表后应为belongToVals[]的子集，为空则视作未传入验证规则，直接继续执行后续操作。

`canNull: boolean = false`：表示参数字符串是否可为空，默认为false

#### 特性

只会对字符串进行操作，判断其是否含","从而判定是否想传入一个列表。

#### 目前的功能

1. 可传入一个字符串列表，参数转换为字符串数组后的取值为此列表的子集

   eg. `@UsePipes(new StringToArrPipe(RoleTypeArr))`

   装在`GET test/generate`接口上，该接口传入的唯一参数roles必须是`RoleTypeArr=[Root, Admin, Judger, User]`中的值

   如果未传入roles字符串，则会报错

### ValidationPipe

## 过滤器

### AuthFilter

为以后扩展而加的过滤器？目前还没有重要作用

[KeyPair的格式]: #KeyPair
[FindAllKeysRecord]: #FindAllKeysRecord
