

# 认证模块

## RoleSignGuard

主要内容。

作用：

1. 根据请求中提供的AccessKey及http签名验证其角色
2. 验证http请求是否被窜改

## KeyModule

提供密钥对及其所具有的权限的CRUD接口，使用Redis存放各角色的密钥对，实现方法为为各角色开一个Hash

### 接口

※**只有root才可访问**

1. POST `/gennerate?roles=$role1,$role2...`

    - ``` generateAddKeyPair```根据请求参数roles签发具有对应角色的密钥对并加入redis

2. DELETE `/del?ak=$AccessKey&roles=$role1,$role2..`

    - `deleteKeyPair`删除密钥对

3. GET `/getall`

    - `getAllKeyPairs`获取所有密钥对

4. GET `/get?ak=$AccessKey(&role=$role)`

    - `getKeyPairByAK`根据AccessKey和可选参数role获取密钥对，暂不支持根据多个role获取

5. POST `/add`

    - 向add的请求应包含一个KeyPair类型具有的字段"ak","sk",“role"（可选）

      [KeyPair的格式]: #KeyPair
      
      


### Service

1. `generateKeyPair`生成一个密钥对
```typescript
async generateKeyPair(roles: string[]): Promise<KeyPair>
```
2. `generateAddKeyPair`生成一个密钥对，其具有roles中含有的角色

```typescript
async generateAddKeyPair(roles: string[]): Promise<KeyPair>;
```
2. `deleteKeyPair`根据公钥accessKey删除密钥对或其具有的角色，若不提供角色，默认删除所有角色。

```typescript
async deleteKeyPair(
  accessKey: string,
  roles?: string[]
): Promise<{ RemovedRoles: string[]; SccessNum: number }>;
```
3. 获取所有密钥对，返回一个键为角色类型，值为密钥对列表的KeyListsDic

[KeyListsDic]: #KeyListsDic


```typescript
async getAllKeyPairs(): Promise<KeyListsDic>；
```
4. `getKeyPair`根据所提供的accessKey和的可选参数role角色在RedisHash中查找密钥对

不提供role则对所有角色的Hash中查找

```typescript
async getKeyPair(accessKey: string, role?: string): Promise<KeyPair>；
```

5. `addKeyPair`将所提供的密钥对keyPair添加到对应其角色role的RedisHash中

```typescript
async addKeyPair(keyPair: KeyPair): Promise<number>
```



## 常量及类型

### 密钥的相关属性

#### 长度、类型

- `rootAccessKey及rootSecretKey`：在application.toml中手动输入生成配置前生成好的，长度为64-256

- 其他：`KEY_LENGTH_NOT_ROOT=64`


#### 生成方式

crypto库中的`generateKeyPairSync()`,带有PUBLICKEY/SECETKEY等字样的前缀或后缀，需截取中间部分1到4行，取中间64位。之所以不采用

```typescript
let { publicKey, privateKey } = generateKeyPairSync("rsa", {
            modulusLength: KEY_LENGTH_NOT_ROOT * 16,
            publicKeyEncoding: {
                type: "spki",
                format: "pem"
            },
            privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
            }
        });
```

在日志中输出accessKey时取前6位

需将生成的pem格式的key中的保留字符：/和+替换掉

###  ```RoleTypeArr:string[]```

存角色的数组

内容：```["root", "admin", "judger", "user"]```

### ```PublicHeadersType:string[]```

公共请求头，在guard中使用（遍历）时按字典序排序

### ```whiteHeaders:string[]```

请求头白名单，计入签名

### KeyPair

 ```typescript
type KeyPair = {
    ak: string | null;
    sk: string | null;
    roles?: string[] | null;
};
 ```

密钥对格式。```ak:AccessKey``` ``` sk:SecretKey``` ``` roles:密钥对具有的角色```

### KeyListsDic

保存各个角色对应的密钥对的列表的字典


```typesctipt
export type KeyListsDic = Record<string, Record<string, string>>;
```
eg:

```typescript
{
"root":{
  "blablaba":"blablabla"
},
"admin":{
  "blablaba":"blablabla",
    "blablaba":"blablabla"
},
"judger":{
  "blablaba":"blablabla",
    "blablaba":"blablabla"
}
}
```



### KeyPairDTO

KeyPair对应的DTO，ak、sk、roles都不能为空，以便`addKeyPair`时进行处理

```typescript
export class KeyPairDto {
    @IsString()
    @IsNotEmpty()
    @Length(KEY_LENGTH_NOT_ROOT, KEY_LENGTH_NOT_ROOT, {
        message: lengthErrorMessage
    })
    ak!: string;

    @IsString()
    @IsNotEmpty()
    @Length(KEY_LENGTH_NOT_ROOT, KEY_LENGTH_NOT_ROOT, {
        message: lengthErrorMessage
    })
    sk!: string;

    @IsString()
    @IsNotEmpty()
    roles!: string[];
}

```



### Redis键含义

```typescript
export const keyPoolPre = "KeyPool";
```

格式为``${keyPoolPre}:${role}``其中role为`RoleTypeArr`中定义的角色

## AuthPipe（）

构造参数vals[]: 表示请求中(或controller中)的参数应属于vals[]中的内容，为空则无限制，

写着以备以后增加验证机制？

## AuthFilter

为以后扩展而加的过滤器？目前还没有重要作用

